
##############

# Reads BLE IMU data from the ESP32C3 Devkit 1 device or Circuit PLayground Bluefruit Device.

    # FUNCTION: 
            # Input Patient Name, Circuitpy Device Name at any time, then hit "Save Inputs" 
                # Default Bluefruit device is CIRCUITPYc67c, have to change manually if using the other one

            # Click "Discover Devices" to scan for ESP32 or Bluefruit devices.
                #Select ESP or Bluefruit device 
                #Only 1 Bluefruit device can be detected at a time.

            # Click "Start" to begin collection of data from selected device

            # Click "Stop" to stop collection of data from selected device
                # Then, the Save Inputs & Device selection can be done again.



    # Uses of the GUI:
        # 1. Device address input for BLE (In case we change devices)
        # 2. Patient name input
            # 2.1. Unique file names are generated by the time stamp anyway, regardless of patient name
                # Example: Could do patient name = Andre and run 3 trials, each trial will be saved with a unique file name due to the timee marker

    # New file generation: new unique file names are produced by a time marker: day-month-year_hour-minute-second

    # Outputs: Saves text files with timestamp, x,y,z accelerometer data like for the Bluefruit
        #For each new file, timestamp starts at 0 and increments each time a notification is received (time is in seconds)
    

    

    # Future Directions: could find a way to automatically detect ESP32 Adress?

##############

import asyncio
import threading
from bleak import BleakClient, BleakScanner
import time
import struct
import os
import tkinter as tk
from tkinter import messagebox

# Default values
ESP32_ADDRESS = "40:4C:CA:8C:60:5A"
Circuitpy_Name= "CIRCUITPYc67c"
selected_device_name = None  # Default to None
patient_name = "Patient X"

# Globals
selected_device_address = ESP32_ADDRESS  # Default to the ESP32 constant
start_time = None
last_notification_time = time.time()
stop_event = threading.Event()
file_path = None

data_display = None  ## Text widget for displaying data
data_buffer = ""  # Global buffer for handling CircuitPy data

device_selection_var = None  # Global variable to hold the selected device


def create_file_path():
    """
    Creates a file path for saving data based on the patient name and current timestamp.
    """
    global file_path
    time_stamp = time.strftime("%d-%b-%Y_%H-%M-%S")
    filename = f"acceleration_data_{patient_name}_{time_stamp}.txt"
    file_path = os.path.join(os.getcwd(), filename)

def parse_accel_data(data):
    """Parse incoming BLE data based on the selected device."""
    global data_buffer
    print(f"Device selected: {device_selection_var.get()}")
    print(f"Raw data received: {data}")
    try:
        if Circuitpy_Name in selected_device_name:
            # CircuitPy sends CSV-like strings: "timestamp,x,y,z"
            data_str = data.decode("utf-8").strip()            
            print(f"Decoded CircuitPy data: {data_str}")
            data_buffer += data_str  # Accumulate data in the buffer

            # Process complete data (timestamp, x, y, z)
            if "," in data_buffer:
                parts = data_buffer.split(",", 3)  # Limit to 4 parts (timestamp, x, y, z)
                if len(parts) == 4:
                    timestamp, x, y, z = parts
                    data_buffer = ""  # Clear buffer after processing
                    return float(x), float(y), float(z)  # Return parsed values
            return None
        else:
            try:
                accel_x, accel_y, accel_z = struct.unpack('<3f', data)
                return accel_x, accel_y, accel_z
            except struct.error:
                print("ESP32 data parse error: data length mismatch.")
                return None, None, None
    except Exception as e:
        print(f"Error parsing data: {e}")
        return None, None, None

def notification_handler(sender: int, data: bytearray):
    global start_time, last_notification_time, data_display

    if start_time is None:
        start_time = time.time()

    current_time = time.time()
    relative_time = current_time - start_time
    try:
        accel_x, accel_y, accel_z = parse_accel_data(data)
        if accel_x is not None and accel_y is not None and accel_z is not None:
            output = f"Relative time: {relative_time:.3f}, Accel: X={accel_x:.4f}, Y={accel_y:.4f}, Z={accel_z:.4f}\n"
            print(output)

            if file_path:
                with open(file_path, "a", encoding="utf-8") as file:
                    file.write(f"{relative_time:.3f},{accel_x},{accel_y},{accel_z}\n")

            if data_display:
                data_display.insert(tk.END, output)
                data_display.see(tk.END)

        else:
            print("Received invalid data, skipping notification.")

    except TypeError as e:
        print(f"Skipping invalid notification data: {e}")


## UPDATES FRO CIRCUITPY
async def discover_devices():
    """Scan for BLE devices, returning a list of discovered devices."""
    print("Scanning for devices...")
    
    devices = await BleakScanner.discover()
    found_devices = []

    # Add devices that match ESP32 or CircuitPy criteria
    for device in devices:
        if device.name and (Circuitpy_Name in device.name or device.address == ESP32_ADDRESS):  
            found_devices.append(device)

    if not found_devices:
        print("No suitable devices found.")
        return None

    print("Discovered devices:")
    for idx, device in enumerate(found_devices, start=1):
        print(f"{idx}: {device.name} ({device.address})")

    return found_devices

def update_device_list(device_dropdown, status_label):
    """Discover BLE devices and update the dropdown menu."""
    async def discover_and_update():
        devices = await discover_devices()
        if not devices:
            status_label.config(text="No devices found.", fg="red")
            return

        # Clear current dropdown options and add devices
        menu = device_dropdown["menu"]
        menu.delete(0, "end")  # Clear old options
        for device in devices:
            menu.add_command(label=f"{device.name} ({device.address})", 
                             command=lambda d=device: [device_selection_var.set(d.address),update_selected_device(d.name),],)
        status_label.config(text="Devices discovered. Select from dropdown.", fg="green")

    # Run discovery in an asyncio loop
    loop = asyncio.new_event_loop()
    threading.Thread(target=run_asyncio_task, args=(loop, discover_and_update())).start()

def update_selected_device(device_name):
    """Update the selected device name globally."""
    global selected_device_name
    selected_device_name = device_name
    print(f"Device selected: {selected_device_name}")

def select_device_gui(found_devices):
    """GUI to let users select a BLE device from discovered options."""
    def set_device_selection():
        selected_index = device_listbox.curselection()
        if selected_index:
            selected_device[0] = found_devices[selected_index[0]]
            root.destroy()

    root = tk.Tk()
    root.title("Select BLE Device")
    tk.Label(root, text="Select a device to connect to:").pack(padx=10, pady=10)

    # Listbox for device selection
    device_listbox = tk.Listbox(root, height=len(found_devices), width=50)
    for idx, device in enumerate(found_devices):
        device_listbox.insert(tk.END, f"{device.name} ({device.address})")
    device_listbox.pack(padx=10, pady=10)

    # Connect button
    tk.Button(root, text="Connect", command=set_device_selection).pack(pady=10)

    # Selected device reference
    selected_device = [None]
    root.mainloop()

    return selected_device[0]

## END UPDATE FOR CIRCUITPY
async def discover_services_and_characteristics(address):
    async with BleakClient(address) as client:
        print(f"Connected to {address}")
        if not client.is_connected:
            print("Failed to connect to the device.")
            return

        if client.services is None:  # Services are not populated until connection
            await client.get_services()

        for service in client.services:
            print(f"Found service: {service.uuid}")
            for char in service.characteristics:
                if "notify" in char.properties:
                    print(f"Characteristic with notify: {char.uuid}")


async def connect_and_subscribe():
    global stop_event
    create_file_path()

    # Step 1: Discover devices - MAY HAVE TO DELETE
    ##found_devices = await discover_devices()
    ##if not found_devices:
    ##    print("No devices found. Please try again.")
    ##    return

    # Step 2: Let the user select a device
    selected_device = device_selection_var.get()##select_device_gui(found_devices)
    if  selected_device == "Select a device":
        print("No device selected. Aborting connection.")
        return

    # Step 3: Connect to the selected device
    async with BleakClient(selected_device) as client: ##ESP32_ADDRESS
        print(f"Connected to {selected_device}")
        if not client.is_connected:
            print("Failed to connect to the device.")
            return

        stop_event.clear()

        services = client.services  # Use the services property
        if services is None:  # Services are not populated until connection
            await client.get_services()

        for service in client.services:
            for char in service.characteristics:
                if "notify" in char.properties:
                    await client.start_notify(char.uuid, notification_handler)
        print("Started receiving notifications. Press 'Stop' to end.")

        while not stop_event.is_set():
            await asyncio.sleep(1)

        if client.services is None:
            await client.get_services()

        for service in client.services:
            for char in service.characteristics:
                if "notify" in char.properties:
                    await client.stop_notify(char.uuid)

        print("Stopped receiving notifications.")

def run_asyncio_task(loop, task):
    asyncio.set_event_loop(loop)
    loop.run_until_complete(task)

def start_collection():
    global ESP32_ADDRESS, patient_name, stop_event, start_time
    stop_event = threading.Event()
    start_time = None  # Reset start_time to ensure it starts fresh for each run    
    loop = asyncio.new_event_loop()
    thread = threading.Thread(target=run_asyncio_task, args=(loop, connect_and_subscribe()))
    thread.start()

def stop_collection():
    global stop_event
    stop_event.set()
    print("Stop event triggered.")

def save_inputs(patient_entry,circuitpy_entry, status_label):
    global selected_device_address, selected_device_name, patient_name, Circuitpy_Name
    selected_device_address = device_selection_var.get()
    patient_name = patient_entry.get()
    Circuitpy_Name = circuitpy_entry.get()
    
     #Validate device selection
    if not selected_device_address or not selected_device_name:
        status_label.config(text="Patient name saved! No device selected!", fg="blue")
    else:
        print(f"Inputs saved: Address={selected_device_address}, Name={selected_device_name}, Patient={patient_name}, CircuitPy Name={Circuitpy_Name}")
        status_label.config(text="Inputs saved successfully!", fg="green")


# GUI Setup
def create_gui():
    global data_display, device_selection_var
    root = tk.Tk()
    root.title("BLE Data Logger")

    tk.Label(root, text="Select Device (ESP32 or CircuitPy):").grid(row=0, column=0, padx=5, pady=5, sticky="e")
    device_selection_var = tk.StringVar(value="Select a device")  # Holds the selected device
    device_dropdown = tk.OptionMenu(root, device_selection_var, "Select a device")  # Initial placeholder
    device_dropdown.grid(row=0, column=1, padx=5, pady=5)


    tk.Label(root, text="Patient Name:").grid(row=1, column=0, padx=5, pady=5, sticky="e")
    patient_entry = tk.Entry(root, width=30)
    patient_entry.insert(0, patient_name)
    patient_entry.grid(row=1, column=1, padx=5, pady=5)

    tk.Label(root, text="CircuitPy Name:").grid(row=2, column=0, padx=5, pady=5, sticky="e")
    circuitpy_entry = tk.Entry(root, width=30)
    circuitpy_entry.insert(0, Circuitpy_Name)
    circuitpy_entry.grid(row=2, column=1, padx=5, pady=5)

    # Status label to show messages within the GUI
    status_label = tk.Label(root, text="", fg="red")
    status_label.grid(row=6, column=0, columnspan=2, pady=5)

    tk.Button(root, text="Save Inputs", command=lambda: save_inputs(patient_entry, circuitpy_entry,status_label)).grid(row=3, column=0, columnspan=2, pady=10)
    tk.Button(root, text="Discover Devices", command=lambda: update_device_list(device_dropdown, status_label)).grid(row=4, column=0, columnspan=2, pady=10)
    tk.Button(root, text="Start", command=start_collection, bg="green", fg="white").grid(row=5, column=0, padx=5, pady=5, sticky="e")
    tk.Button(root, text="Stop", command=stop_collection, bg="red", fg="white").grid(row=5, column=1, padx=5, pady=5, sticky="w")

    data_display = tk.Text(root, height=15, width=50)
    data_display.grid(row=7, column=0, columnspan=2, padx=5, pady=5)

    root.mainloop()

if __name__ == "__main__":
    create_gui()
