
##############

# Reads BLE IMU data from the ESP32C3 Devkit 1 device

    # Uses GUI:
        # 1. Device address inputfor BLE (In case we change devices)
        # 2. Patient name input
            # 2.1. Unique file names are generated by the time stamp anyway, regardless of patient name
                # Example: Could do patient name = Andre and run 3 trials, each trial will be saved with a unique file name due to the timee marker

    # New file generation: new unique file names are produced by a time marker: day-month-year_hour-minute-second

    # Outputs: Saves text files with timestamp, x,y,z accelerometer data like for the Bluefruit
        #For each new file, timestamp starts at 0 and increments each time a notification is received (time is in seconds)
    

    # Future Directions: could find a way to automatically detect ESP32 Adress?

##############

import asyncio
import threading
from bleak import BleakClient, BleakScanner
import time
import struct
import os
import tkinter as tk
from tkinter import messagebox

# Default values
ESP32_ADDRESS = "40:4C:CA:8C:60:5A"
patient_name = "Patient X"

# Globals
start_time = None
last_notification_time = time.time()
stop_event = threading.Event()
file_path = None

data_display = None  ## Text widget for displaying data

def create_file_path():
    """
    Creates a file path for saving data based on the patient name and current timestamp.
    """
    global file_path
    time_stamp = time.strftime("%d-%b-%Y_%H-%M-%S")
    filename = f"acceleration_data_{patient_name}_{time_stamp}.txt"
    file_path = os.path.join(os.getcwd(), filename)

def parse_accel_data(data):
    accel_x, accel_y, accel_z = struct.unpack('<3f', data)
    return accel_x, accel_y, accel_z

def notification_handler(sender: int, data: bytearray):
    global start_time, last_notification_time, data_display

    if start_time is None:
        start_time = time.time()

    current_time = time.time()
    relative_time = current_time - start_time
    accel_x, accel_y, accel_z = parse_accel_data(data)


    output = f"Relative time: {relative_time:.3f}, Accel: X={accel_x:.4f}, Y={accel_y:.4f}, Z={accel_z:.4f}\n"
    print(output)

    if file_path:
        with open(file_path, "a", encoding="utf-8") as file:
            file.write(f"{relative_time:.3f},{accel_x},{accel_y},{accel_z}\n")

    if data_display:
        data_display.insert(tk.END, output)
        data_display.see(tk.END)


async def discover_services_and_characteristics(address):
    async with BleakClient(address) as client:
        print(f"Connected to {address}")
        if not client.is_connected:
            print("Failed to connect to the device.")
            return

        if client.services is None:  # Services are not populated until connection
            await client.get_services()

        for service in client.services:
            print(f"Found service: {service.uuid}")
            for char in service.characteristics:
                if "notify" in char.properties:
                    print(f"Characteristic with notify: {char.uuid}")


async def connect_and_subscribe():
    global stop_event
    create_file_path()

    async with BleakClient(ESP32_ADDRESS) as client:
        print(f"Connected to {ESP32_ADDRESS}")
        if not client.is_connected:
            print("Failed to connect to the device.")
            return

        stop_event.clear()

        services = client.services  # Use the services property
        if services is None:  # Services are not populated until connection
            await client.get_services()

        for service in client.services:
            for char in service.characteristics:
                if "notify" in char.properties:
                    await client.start_notify(char.uuid, notification_handler)


        print("Started receiving notifications. Press 'Stop' to end.")

        while not stop_event.is_set():
            await asyncio.sleep(1)

        #for service in await client.get_services():
        if client.services is None:
            await client.get_services()

        for service in client.services:
            for char in service.characteristics:
                if "notify" in char.properties:
                    await client.stop_notify(char.uuid)

        print("Stopped receiving notifications.")

def run_asyncio_task(loop, task):
    asyncio.set_event_loop(loop)
    loop.run_until_complete(task)

def start_collection():
    global ESP32_ADDRESS, patient_name, stop_event, start_time
    stop_event = threading.Event()
    start_time = None  # Reset start_time to ensure it starts fresh for each run


    loop = asyncio.new_event_loop()
    thread = threading.Thread(target=run_asyncio_task, args=(loop, connect_and_subscribe()))
    thread.start()

def stop_collection():
    global stop_event
    stop_event.set()
    print("Stop event triggered.")

def save_inputs(esp32_entry, patient_entry, status_label):
    global ESP32_ADDRESS, patient_name
    ESP32_ADDRESS = esp32_entry.get()
    patient_name = patient_entry.get()
    status_label.config(text="Inputs saved successfully!", fg="green")


# GUI Setup
def create_gui():
    global data_display
    root = tk.Tk()
    root.title("BLE Data Logger")

    tk.Label(root, text="ESP32 Address:").grid(row=0, column=0, padx=5, pady=5, sticky="e")
    esp32_entry = tk.Entry(root, width=30)
    esp32_entry.insert(0, ESP32_ADDRESS)
    esp32_entry.grid(row=0, column=1, padx=5, pady=5)

    tk.Label(root, text="Patient Name:").grid(row=1, column=0, padx=5, pady=5, sticky="e")
    patient_entry = tk.Entry(root, width=30)
    patient_entry.insert(0, patient_name)
    patient_entry.grid(row=1, column=1, padx=5, pady=5)

    # Status label to show messages within the GUI
    status_label = tk.Label(root, text="", fg="red")
    status_label.grid(row=4, column=0, columnspan=2, pady=5)

    tk.Button(root, text="Save Inputs", command=lambda: save_inputs(esp32_entry, patient_entry, status_label)).grid(row=2, column=0, columnspan=2, pady=10)
    tk.Button(root, text="Start", command=start_collection, bg="green", fg="white").grid(row=3, column=0, padx=5, pady=5, sticky="e")
    tk.Button(root, text="Stop", command=stop_collection, bg="red", fg="white").grid(row=3, column=1, padx=5, pady=5, sticky="w")

    data_display = tk.Text(root, height=15, width=50)
    data_display.grid(row=5, column=0, columnspan=2, padx=5, pady=5)

    root.mainloop()

if __name__ == "__main__":
    create_gui()
